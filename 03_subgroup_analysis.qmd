---
title: "Subgroup analysis"
subtitle: "Workflow to establish a subgroup analysis after multiple imputation and propensity Score matching"
author: Janick Weberpals, RPh, PhD
date: last-modified
format: html
code-fold: false
toc: true
toc-depth: 3
code-tools: true
keep-md: true
editor: visual
bibliography: references.bib
---

This is a reproducible example on how to establish a workflow to run a subgroup analysis after multiple imputation and propensity Score matching.

Load packages:

```{r}
#| label: setup
#| message: false

library(dplyr)
library(survival)
library(mice)
library(MatchThem)
library(survey)
library(here)
library(gtsummary)
library(parallelly)
library(ranger)
library(furrr)

source(here("functions", "source_encore.io_functions.R"))
```

## About

This script is adapted from Noah Greifer's highly recommended blog post on "[Subgroup Analysis After Propensity Score Matching Using R](https://ngreifer.github.io/blog/subgroup-analysis-psm/)".

For a more formal manuscript on subgroup analysis with propensity scores, see Green and Stuart.[@Green2014]

## Data generation

We again use the `simulate_flaura()` function to simulate a realistic oncology comparative effectiveness cohort analytic dataset.

```{r}
#| label: data_generation
#| warning: false

# load example dataset with missing observations
data_miss <- simulate_flaura(
  n_total = 3500, 
  treat_prevalence = .51, 
  seed = 42, 
  include_id = FALSE, 
  imposeNA = TRUE
  )

covariates <- data_miss |> 
  select(starts_with("c_"), starts_with("dem_")) |> 
  select(-dem_sex_cont) |> 
  colnames()

head(data_miss)
```

## Moderator covariate

In this example, we assume heterogeneous treatment effect by sex and we aim to assess the average treatment effect among the treated for female and male patients separately. The effect size is time to all-cause mortality. In this dataset, sex is encoded with a binary covariate with 0 = female and 1 = male.

```{r}
table(data_miss$dem_sex_cont)
```

## Multiple imputation

Both the imputation and propensity score step Multiple imputation using `mice:`

```{r}
#| label: mice

female_imp <- imputation_workflow(
  ard_eligible = data_miss |> filter(dem_sex_cont == 0) |> select(-dem_sex_cont),
  database = "edb1",
  cancer = "aNSCLC",
  covars_for_imputation = covariates
  )

# impute data
female_imp <- futuremice(
  parallelseed = 42,
  n.core = parallel::detectCores()-1,
  data = data_miss |> filter(dem_sex_cont == 0) |> select(-dem_sex_cont),
  method = "rf",
  m = 10,
  print = FALSE
  )

male_imp <- futuremice(
  parallelseed = 42,
  n.core = parallel::detectCores()-1,
  data = data_miss |> filter(dem_sex_cont == 1) |> select(-dem_sex_cont),
  method = "rf",
  m = 10,
  print = FALSE
  )
```

## Propensity score matching and weighting

Apply propensity score matching and weighting with replacement within in each imputed dataset.

### Matching

```{r}
#| label: matching
#| warning: false

# apply propensity score matching on mids object
ps_form <- as.formula(paste("treat ~", paste(covariates, collapse = " + ")))

# female data matching 
female_mimids <- matchthem(
  formula = ps_form,
  datasets = female_imp,
  approach = 'within',
  method = 'nearest',
  caliper = 0.01,
  ratio = 1,
  replace = F
  )

# male data matching 
male_mimids <- matchthem(
  formula = ps_form,
  datasets = male_imp,
  approach = 'within',
  method = 'nearest',
  caliper = 0.01,
  ratio = 1,
  replace = F
  )
```

```{r}
bal.plot(male_mimids, which.imp = .none, which = "both")
bal.plot(female_mimids, which.imp = .none, which = "both")
```

### Weighting

```{r}
#| label: weighting
#| warning: false

# female data weighting 
female_wimids <- weightthem(
  formula = ps_form,
  datasets = female_imp,
  approach = 'within',
  method = "glm",
  estimand = "ATT"
  )

# trim extreme weights
female_wimids <- trim(
  x = female_wimids, 
  at = .95, 
  lower = TRUE
  )

# male data weighting 
male_wimids <- weightthem(
  formula = ps_form,
  datasets = male_imp,
  approach = 'within',
  method = "glm",
  estimand = "ATT"
  )

# trim extreme weights
male_wimids <- trim(
  x = male_wimids, 
  at = .95, 
  lower = TRUE
  )
```

```{r}
love.plot(male_wimids, which.imp = .none, which = "both")
love.plot(female_wimids, which.imp = .none, which = "both")
```

## Outcome model comparisons

Next, we compare the marginal treatment effect estimates coming from a Cox proportional hazards model after propensity score matching and weighting as implemented in the `coxph()` and in the `svycoxph()` functions.

From the `MatchThem` documentation:

::: callout-important
-   `with()` applies the supplied model in `expr` to the (matched or weighted) multiply imputed datasets, automatically incorporating the (matching) weights when possible. The argument to `expr` should be of the form `glm(y ~ z, family = quasibinomial)`, for example, excluding the data or weights argument, which are automatically supplied.

-   Functions from the **survey** package, such as `svyglm()`, are treated a bit differently. No `svydesign` object needs to be supplied because `with()` automatically constructs and supplies it with the imputed dataset and estimated weights. When `cluster = TRUE` (or `with()` detects that pairs should be clustered; see the `cluster` argument above), pair membership is supplied to the `ids` argument of `svydesign()`.

-   After weighting using `weightthem()`, `glm_weightit()` should be used as the modeling function to fit generalized linear models. It correctly produces robust standard errors that account for estimation of the weights, if possible. See [`WeightIt::glm_weightit()`](http://127.0.0.1:31281/help/library/WeightIt/help/glm_weightit) for details. Otherwise, `svyglm()` should be used rather than `glm()` in order to correctly compute standard errors.

-   **For Cox models, `coxph()` will produce approximately correct standard errors when used with weighting, but `svycoxph()` will produce more accurate standard errors when matching is used.**
:::

::: panel-tabset
### Matching

We now want to compare treatment effect estimates for `treat` when computed (a) using `coxph` (survival package) and (b) `svycoxph` (survey package). More information on estimating treatment effects after matching is provided in <https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html#survival-outcomes>

#### `coxph`

```{r}
#| label: coxph_mimids
#| results: hide

# coxph result
coxph_results <- with(
  data = data_mimids,
  expr = coxph(formula = Surv(fu_itt_months, death_itt) ~ treat, 
               weights = weights, 
               cluster = subclass,
               robust = TRUE
               )
  ) |> 
  pool() |> 
  tidy(exponentiate = TRUE, conf.int = TRUE) |> 
  mutate(package = "survival") |> 
  select(package, term, estimate, std.error, conf.low, conf.high) 

coxph_results
```

#### `svycoxph`

```{r}
#| label: svycoxph_mimids
#| results: hide

# svycoxph result
svycoxph_results <- with(
  data = data_mimids,
  expr = svycoxph(formula = Surv(fu_itt_months, death_itt) ~ treat),
  cluster = TRUE
  ) |> 
  pool() |> 
  tidy(exponentiate = TRUE, conf.int = TRUE) |> 
  mutate(package = "survey") |> 
  select(package, term, estimate, std.error, conf.low, conf.high)

svycoxph_results
```

#### Summary

```{r}
rbind(coxph_results, svycoxph_results)
```

### Weighting

#### `coxph`

```{r}
#| label: coxph_wimids
#| results: hide

# coxph result
coxph_results <- with(
  data = data_wimids,
  expr = coxph(formula = Surv(fu_itt_months, death_itt) ~ treat,
               weights = weights, 
               robust = TRUE
               )
  ) |> 
  pool() |> 
  tidy(exponentiate = TRUE, conf.int = TRUE) |> 
  mutate(package = "survival") |> 
  select(package, term, estimate, std.error, conf.low, conf.high) 

coxph_results
```

#### `svycoxph`

```{r}
#| label: svycoxph_wimids
#| results: hide

# svycoxph result
svycoxph_results <- with(
  data = data_wimids,
  expr = svycoxph(formula = Surv(fu_itt_months, death_itt) ~ treat),
  cluster = TRUE
  ) |> 
  pool() |> 
  tidy(exponentiate = TRUE, conf.int = TRUE) |> 
  mutate(package = "survey") |> 
  select(package, term, estimate, std.error, conf.low, conf.high) 

svycoxph_results
```

#### Summary

```{r}
rbind(coxph_results, svycoxph_results)
```
:::
